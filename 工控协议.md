## 工控协议学习

#### 学习工具包

https://github.com/automayt/ICS-pcap

https://wiki.wireshark.org/SampleCaptures

#### 常见协议总结

|            工控协议            | 传输协议 |        端口         |                             说明                             |                       zoomeye查询链接                        |
| :----------------------------: | :------: | :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|             Modbus             |   TCP    |         502         | 工控常用协议，Modbus协议是应用于电子控制器上的一种协议。通过此协议设备间可以通信。它已成为一通用工业标准。 | [port:502](https://www.zoomeye.org/searchResult?q=port:502)  |
|           Siemens S7           |   TCP    |         102         | 西门子PLC支持的通讯协议。属于第7层的协议，用于西门子设备之间进行交换数据，通过TSAP，可加载MPI,DP,以太网等不同物理结构总线或网络上，PLC一般可以通过封装好的通讯功能块实现。 s7协议是SIEMENS s7协议族的标准通信协议，使用s7-应用接口的通信不依赖特定的总线系统。 | [port:102](https://www.zoomeye.org/searchResult?q=port:102)  |
|             BACnet             | TCP/UDP  |        47808        | 楼宇自动控制网络数据通讯协议。楼宇自动控制网络数据通讯协议（A Data Communication Protocol for Building Automation and Control Networks）。BACnet 协议是为计算机控制采暖、制冷、空调HVAC系统和其他建筑物设备系统定义服务和协议。 楼宇自动控制网络数据通讯协议(BACnet)是针对采暖、通风、空调、制冷控制设备所设计，同时也为其他楼宇控制系统（例如照明、安保、消防等系统）的集成提供一个基本原则。 | [port:47808](https://www.zoomeye.org/searchResult?q=port:47808) |
|              ATG               |   TCP    |        10001        | ATG，油罐液位仪，一种储油罐的监测设备；ATG（Automated-Tank-Gauge）协议是液位仪器的私有通讯协议 | [port:10001](https://www.zoomeye.org/searchResult?q=port:10001) |
|           `IEC 104`            |   TCP    |        2404         | 输配电通讯协议。`IEC 104`=`IEC 60870-5-104`是国际电工委员会制定的一个规范，用于适应和引导电力系统调度自动化的发展，规范调度自动化及远动设备的技术性能。 | [port:2404](https://www.zoomeye.org/searchResult?q=port:2404) |
|        `DNP3`=`DNP 3.0`        | TCP/UDP  |        20000        | `DNP`=`Distributed Network Protocol`=`分布式网络协议` 是一种应用于自动化组件之间的通讯协议，常见于电力、水处理等行业。分布式网络协议，主要用于电力行业。SCADA可以使用DNP协议与主站、RTU、及IED进行通讯。 简化OSI模型，只包含了物理层，数据层与应用层的体系结构（EPA） | [port:20000](https://www.zoomeye.org/searchResult?q=port:20000) |
|              ICCP              |          |                     |                     电力控制中心通讯协议                     |                                                              |
|              OPC               |          |                     | 过程控制的OLE （OLE for Process Control）。OPC包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统 |                                                              |
|             OPC DA             |   TCP    |         135         | OPC（OLE for Process Control, 用于过程控制的OLE）是一个工业标准。OPC包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。OPC DA基于微软的OLE、COM和DCOM技术 |                                                              |
|             OPC UA             |   TCP    |        4840         | opc-ua tcp4840 port:4840 OPC-UA（Unified Architecture）是下一代的OPC 标准，通过提供一个完整的、安全和可靠的跨平台的架构，以获取实时和历史数据和时间。OPC UA不再依靠DCOM，而是基于面向服务的架构 （SOA） |                                                              |
|              CIP               |          |                     | 通用工业协议，被`DeviceNet`、`ControlNet`、`EtherNet/IP`三种网络所采用 |                                                              |
|      Tridium Niagara Fox       |   TCP    |        1911         | Fox协议是Tridium公司开发的Niagara框架的一部分，广泛应用于楼宇自动化控制系统 | [port:1911](https://www.zoomeye.org/searchResult?q=port:1911) |
|           Crimson V3           |   TCP    |         789         |                                                              | [port:789](https://www.zoomeye.org/searchResult?q=port:789)  |
|             PCWorx             |   TCP    |        1962         | PCWorx协议由菲尼克斯电气公司开发，目前广泛使用于工控系统。PCWORX3.11是菲尼克斯电气公司的专用协议 | [port:1962](https://www.zoomeye.org/searchResult?q=port:1962) |
|            ProConOs            |   TCP    |        20547        | ProConOS是德国科维公司(KW-Software GmbH)开发的用于PLC的实时操作系统，它是一个高性能的PLC运行时引擎，目前广泛使用于基于嵌入式和PC的工控系统 | [port:20547](https://www.zoomeye.org/searchResult?q=port:20547) |
|            MELSEC-Q            | TCP/UDP  | tcp 5007 / UDP 5006 | MELSEC-Q系列设备使用专用的网络协议进行通讯，该系列设备可以提供高速、大容量的数据处理和机器控制 | [port:5007](https://www.zoomeye.org/searchResult?q=port:5007)，[port:5006](https://www.zoomeye.org/searchResult?q=port:5006) |
| `IEC-61850` = MMS + goose + SV |   TCP    |         102         | 输配电通讯协议。IEC 61850标准是电力系统自动化领域唯一的全球通用标准。它通过标准的实现，实现了智能变电站的工程运作标准化。使得智能变电站的工程实施变得规范、统一和透明 |                                                              |
|            GE SRTP             |   TCP    |        18245        | GE-SRTP协议由美国通用电气公司开发，GE PLC可以通过GE-SRTP进行数据通信和数据传输 |                                                              |
|            CANopen             |          |                     |                      控制局域网通讯协定                      |                                                              |
|            `ONVIF`             |   UDP    |        3702         | ONVIF协议的开发目的是通过全球性的开放接口标准来推进网络视频在安防市场的应用，这一接口标准将确保不同厂商生产的网络视频产品具有互通性 |                                                              |

|   **工业现场总线**    |         |                   |                                                              |                                                              |
| :-------------------: | :-----: | :---------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|       PROFIBUS        |         |                   | 一种用于工厂自动化车间级监控和现场设备层数据通信与控制的现场总线技术，可实现现场设备层到车间级监控的分散式数字控制和现场通信网络 |                                                              |
|     `EtherNet/IP`     | TCP/UDP |       44818       | Ethernet/IP是一个面向工业自动化应用的工业应用层协议。它建立在标准UDP/IP与TCP/IP协议之上，利用固定的以太网硬件和软件，为配置、访问和控制工业自动化设备定义了一个应用层协议。 是一种CIP的实现方式，由罗克韦尔自动化公司开发的工业以太网通讯协定。 | [port:44818](https://www.zoomeye.org/searchResult?q=port:44818) |
|       Profinet        |         |                   |                  开放式的工业以太网通讯协定                  |                                                              |
|       EtherCAT        |         |                   |        德国Beckhoff公司推动的开放式实时以太网通讯协定        |                                                              |
|        HART-IP        | TCP/UDP |       5094        | HART协议是美国Rosement公司于1985年推出的一种用于现场智能仪表和控制室设备之间的通信协议。现已成为全球智能仪表的工业标准 |                                                              |
|                       |         |                   |                                                              |                                                              |
|    **PLC通信协议**    |         |                   |                                                              |                                                              |
|        MELSEC         | TCP/UDP | TCP 5007 UDP 5006 |                   三菱Q PLC支持的通讯协议                    |                                                              |
|      OMRON FINS       | TCP/UDP |       9600        | 欧姆龙PLC支持的通讯协定。欧姆龙PLC使用网络协议FINS进行通信，可通过多种不同的物理网络，如以太网、控制器连接等。 | [port:9600](https://www.zoomeye.org/searchResult?q=port:9600) |
|          EGD          |         |                   |                 GE Fanuc为PLC开发的通讯协定                  |                                                              |
|       Sinec H1        |         |                   |                   西门子PLC支持的通讯协议                    |                                                              |
|     **无线协议**      |         |                   |                                                              |                                                              |
|         mqtt          |         |                   |                                                              |                                                              |
|        zigbee         |         |                   |                     开放式的无线通讯协定                     |                                                              |
|                       |         |                   |                                                              |                                                              |
|   **主流网络协议**    |         |                   |                                                              |                                                              |
|         RTPS          |   TCP   |        554        | RTSP协议是一种实时流传输协议，该协议定义了一对多应用程序如何有效地通过IP网络传送多媒体数据 |                                                              |
|          SIP          |   TCP   |       5060        | SIP协议是由IETF制定的多媒体通信协议，SIP的开发目的是用来帮助提供跨越因特网的高级电话业务 |                                                              |
|                       |         |                   |                                                              |                                                              |
|     **其他协议**      |         |                   |                                                              |                                                              |
|        IEC 103        |         |                   |                                                              |                                                              |
|      Power Link       |         |                   |                     开放式实时以太网通信                     |                                                              |
|        FF HSE         |         |                   |                 基金会现场总线以太网通信协定                 |                                                              |
|         CoAP          |         |                   |                        轻量应用层协议                        |                                                              |
|      openSAFETY       |         |                   |                       开源安全应用协议                       |                                                              |
|      SERCOS III       |         |                   |                      实时以太网通讯协定                      |                                                              |
|      TTEthernet       |         |                   |                      实时以太网通讯协定                      |                                                              |
|          CDT          |         |                   |                           远动规约                           |                                                              |
|       KNXnet/IP       |         |                   |                      住宅和楼宇控制标准                      |                                                              |
|        Lontalk        |         |                   |           埃施朗公司的LonWorks技术所使用的通讯协议           |                                                              |
|       SAE J1939       |         |                   |           一种CAN的变种，适用在农业车辆及商用车辆            |                                                              |
|    USITT DMX512-A     |         |                   |                     灯光控制数据传输协议                     |                                                              |
|      BSSAP/BSAP       |         |                   |             由Bristol Babcock Inc发展的通讯协定              |                                                              |
|        Gryphon        |         |                   |                         车用通讯协定                         |                                                              |
|         Doip          |         |                   |                         汽车诊断协议                         |                                                              |
|        AUTOSAR        |         |                   |                       汽车开放系统协议                       |                                                              |
|   redlion-crimson3    |   TCP   |        789        | 协议被Crimson桌面软件用于与Red Lion G306工控系统的HMI人机接口 |                                                              |
|          Fox          |   TCP   |       1911        | Fox协议是Tridium公司开发的Niagara框架的一部分，广泛应用于楼宇自动化控制系统 |                                                              |
|      secure-fox       |   TCP   |       4911        | Fox协议是Tridium公司开发的Niagara框架的一部分，广泛应用于楼宇自动化控制系统 |                                                              |
|      moxa-nport       |   UDP   |       4800        | Moxa串口服务器专为工业应用而设计。不通配置组合的串口服务器更能符合不同工业现场的需求。NPort系列串口服务器让传统 RS-232/422/485设备立即联网，提供您基于IP的串口联网解决方案 |                                                              |
|        CoDeSys        |   TCP   |       2455        | CoDeSys编程接口在全球范围内使用广泛，全球上百个设备制造商的自动化设备中都是用了该编程接口 |                                                              |
|          ddp          | TCP/UDP |       5002        | DDP协议（DTU DSC Protocol）是DTU与DSC之间的通讯协议，DDP是一种厂商定义的私有公开性质的通信协议，用于数据的传输和DTU管理 |                                                              |
|     lantronix-udp     |   TCP   |       30718       | Lantronix串口服务器专为工业应用而设计。串口服务器是一种具有串口转以太网功能的设备，它能将RS-232/485/422串口转换成TCP/IP网络接口，串口服务器广泛的应用在SCADA数据采集环节上，用于解决串口和以太网的通信问题 |                                                              |
|        wdbrpc         |   TCP   |       17185       | VxWorks是世界上使用最广泛的一种在嵌入式系统中部署的实时操作系统，是由美国WindRiver公司于1983年设计开发的。VxWorks系统在工业控制领域应用较广泛。WDB RPC是VxWorks的远程调试协议 |                                                              |
|       dahua-dvr       |   TCP   |       37777       | DAHUA-DVR协议是浙江大华安防监控设备的私有通信协议，该协议用于实时视频流量的传输 |                                                              |
|     vstarcam-udp      |   UDP   |       8600        | VSTARCAM-UDP协议是威视达康安防监控设备的私有通信协议该协议用于获取安防监控设备的网络配置等信息 |                                                              |
|         CSPV4         |   TCP   |       2222        | CSPV4是可以识别PLC5/SLC 500控制器的服务；罗克韦尔的SLC 500功能强大，拥有先进的指令集、丰富的输入输出模块，专门针对工业现场恶劣的工作环境而设计 |                                                              |
| general-electric-srtp |   TCP   |       18245       | GE-SRTP协议由美国通用电气公司开发，GE PLC可以通过GE-SRTP进行数据通信和数据传输 |                                                              |
|                       |         |                   |                                                              |                                                              |
|     **私有协议**      |         |                   |                                                              |                                                              |
|     bachmann-tcp      |   TCP   |       3500        | Bachmann是一种私有协议，用于Bachmann PLC的通讯，常见于风力发电等行业 |                                                              |
|     bachmann-udp      |   UDP   |       3003        | Bachmann是一种私有协议，用于Bachmann PLC的通讯，常见于风力发电等行业 |                                                              |
|      beckoff-ads      |   UDP   |       48899       | Beckoff-ads是一种私有协议，用于Beckoff PLC的通讯，常见于风力发电等行业 |                                                              |
|      hollysys-lk      |   UDP   |       6000        | Hollysys-lk协议是一种私有协议，用于Hollysys PLC的通讯，常见于电力、石油、化工等行业 |                                                              |
|     hollysys-macs     |   UDP   |       8000        | Hollysys-macs协议是一种私有协议，用于Hollysys DCS的通讯，常见于电力、石油、化工等行业 |                                                              |
|    siemens-license    |   TCP   |       4410        | Siemens License协议是一种私有协议，用于西门子上位机软件的License服务 |                                                              |
|         igss          |   TCP   |       12397       | IGSS协议是一种私有协议，用于IGSS（Interactive Graphical SCADA System）软件之间的通讯 |                                                              |
|        foxboro        |   TCP   |       20476       | Foxboro是一种私有协议，用于Foxboro PLC的通讯，常见于电力、石油、化工等行业 |                                                              |
|   ilon-smartserver    |   TCP   |       1628        | ILON-SMARTSERVER协议是ECHELON公司生产的iLon系列产品的私有通信协议，iLon系列产品可以广泛的应用于工业控制领域；iLon SmartServer类似于一台服务器，起着指令分发，数据存储等作用 |                                                              |

#### Modbus协议

- 基础知识

  最初实现目的是为了串行通信，运行在串口传输上，最开始分为ModbusRTU和Modbus ASCII，目前最多使用的是基于TCP/IP的Modbus TCP

  Modbus为通信协议，也就是适用于应用层的报文传输协议，可以在物理层上进行串口连接，也可以使用TCP的方式进行传输

  Modbus协议定义了一个和基础通信层无关的**简单协议数据单元PDU**，特定总线或者网络上其他Modbus协议映射可以在**应用数据单元ADU**上引入附加域

  ![image-20210726105436990](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726105436990.png)

  Modbus目前在串口上主要使用Modbus Serial协议，而TCP/IP的网络层面上主要使用ModbusTCP协议

- Modbus Serial协议

  - 介绍

    主要实现物理层面的串口通信，分为ModbusRTU和Modbus ASCII两种协议，是Modbus早期的协议

  - ModbusASCII

    - 通讯为普通文本ASCII

    - 常用报文格式

      | 起始位  | 设备地址 | 功能代码 | 数据区  | LRC校验 |     结束符      |
      | :-----: | :------: | :------: | :-----: | :-----: | :-------------: |
      | 1个字节 | 2个字节  | 2个字节  | n个字节 | 2个字节 |     2个字节     |
      |    :    |          |          |         |         | CRLF(回车 换行) |

      LRC：位和求反加一

  - Modbus RTU

    - 通信为二进制传输，RTU通信就是通过模拟远程终端设备读写寄存器，Remote Terminal Unit

  - 对比

    | 协程序议 | 开始标记 | 结束标记 |     校验     | 传输效率 |      程序处理      |
    | :------: | :------: | :------: | :----------: | :------: | :----------------: |
    |  ASCII   |  : 冒号  |   CRLF   | LRC 纵向冗长 |    低    | 直观简单，方便调试 |
    |   RTU    |    无    |    无    | CRC 循环冗长 |    高    |  不直观，较为复杂  |

  - 架构

    一主多从结构，即主站发起请求，从站负责响应

- Modbus TCP协议

  - 协议栈 Modbus为应用层消息传递协议，位于OSI模型的第七层

    ![image-20210726110751991](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726110751991.png)

    ![image-20210726110843906](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726110843906.png)

  - 协议 报文

    - ASCII

      ![image-20210726111120128](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726111120128.png)

    - RTU

      ![image-20210726111126383](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726111126383.png)

    - 通用消息帧

      ![image-20210726111134467](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726111134467.png)

- 功能码

  功能码主要是用于主设备向从设备发送指令，有效范围为1~255之间，大部分位保留，比如128~255为异常响应保留

  - 功能码例子
    - 01 读线圈状态
    - 02 读离散输入状态
    - 03 读保持寄存器
    - 04 读输入寄存器
    - 05 写单个线圈

  Modbus将读写指令分为两个类，首先是离散类，就是对位进行操作，非0即1；另一个就是模拟类，也就是字操作，每一类都有输入输出之分

  - DO 离散类数字量输出，就是离散的输出状态，比如灯泡如果可以放到控制器上，0和1就是控制开关的
  - DI 离散类数字量输入，就是上面灯泡我们如果想知道灯泡目前的情况，就输入02，如果是1就是按开关了灯亮着，如果是0就是没按，DI一般不可写，一般都是读取操作
  - AO 模拟类输出，保存寄存器的功能，区别就是不在局限0和1，可以是一些PID参数，也可以是温度的相关参数
  - AI 模拟类输入，输入寄存器的功能，可读不可写

- Modbus TCP的数据格式

  ```
  Transaction identifier: 事务标识符
  Protocol identifier: 默认为0
  Length: 数据的长度
  Unit identifier: 从机的地址，使用了TCP/IP所以使用ip地址来标识从机
  Function code: Modbus的功能码
  Data:
  ```

  主要在TCP/IP的基础上进一步修改：

  1. TCP/IP本身具有数据校验功能，所以应用数据单元ADU的差错校验没有了
  2. IP可以确认从机，因此附加地址不再有效，而目标可以继续为主，继续向下一个从发信息，因此ADU的附加地址可以作为下一个主机分发数据包的地址
  3. 添加了协议标识符、Length等TCP/IP的头部

- 题目样例

  打开题目后可以看到基本上都是关于modbus/tcp的流量，分析功能码

  ```python
  import pyshark
  
  def get_modbus_code():
      pcaps = pyshark.FileCapture("question1_modbus.pcap")
      codes = {}
      for pcap in pcaps:
          for pkt in pcap:
              if pkt.layer_name == "modbus":
                  code = int(pkt.func_code)
                  if code in codes:
                      codes[code] += 1
                  else:
                      codes[code] = 1
      print(codes)
  def main():
      get_modbus_code()
  
  if __name__ == '__main__':
      main()
  ```

  ![image-20210726115255926](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726115255926.png)

  1 3 4 2都是出现了702次，存在规律，但是16预置多个寄存器只出现了两次，可能出现关键数据，进一步分析16功能码

  ```python
  import pyshark
  
  def get_modbus_code():
      pcaps = pyshark.FileCapture("question1_modbus.pcap")
      codes = {}
      for pcap in pcaps:
          for pkt in pcap:
              if pkt.layer_name == "modbus":
                  code = int(pkt.func_code)
                  if code in codes:
                      codes[code] += 1
                  else:
                      codes[code] = 1
      print(codes)
  
  def hex_to_ascii(payload):
      data = payload
      flags = []
      for d in data:
          _ord = ord(d)
          if (_ord > 0) and (_ord < 128):
              flags.append(chr(_ord))
      return ''.join(flags)
  
  def get_16():
      pcaps = pyshark.FileCapture("question1_modbus.pcap")
      idx = 1
      for pcap in pcaps:
          for pkt in pcap:
              if pkt.layer_name == "modbus":
                  code = int(pkt.func_code)
                  if code == 16:
                      payload = str(pcap["TCP"].payload).replace(":","")
                      print(hex_to_ascii(payload))
                      print("{0} *".format(idx))
          idx += 1
  def main():
      # get_modbus_code()
      get_16()
  if __name__ == '__main__':
      main()
  ```

  得到一串十六进制，在线转成ascii

  ![image-20210726120048210](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210726120048210.png)

#### UMAS(Unified Messaging Application Services)

- 基础知识

  UMAS即同意消息传递应用服务，适用于交换应用程序数据的平台独立协议，通信数据使用的为标准的Modbus协议，Modbus协议的功能码90即0x5A就是UMAS协议的标志

  UMAS协议是施耐德电气私有的，对其PLC产品进行配置和监控操作

- UMAS协议功能码

  UMAS协议 = 0x5A功能码的Modbus协议

  ![image-20210727101350927](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210727101350927.png)

  比如上图中func基本都为90功能码，也就是都为Unity(Schneider)(90)

  | 序号 | 功能码 |              含义              |                                  |
  | :--: | :----: | :----------------------------: | :------------------------------: |
  |  1   |  0x01  |           INIT_COMM            |           建立UMAS通信           |
  |  2   |  0x02  |            READ_ID             |            请求PLC ID            |
  |  3   |  0x03  |       READ_PROJECT_INFO        |        读取PLC中工程信息         |
  |  4   |  0x04  |         READ_PLC_INFO          |         读取PLC内部信息          |
  |  5   |  0x06  |         READ_CARD_INFO         |         读取PLC SD卡信息         |
  |  6   |  0x0A  |             REPEAT             |       回传发送给PLC的数据        |
  |  7   |  0x10  |      TAKE_PLC_RESERVATION      |             独占PLC              |
  |  8   |  0x11  |    RELEASE_PLC_RESERVATION     |             释放PLC              |
  |  9   |  0x12  |           KEEP_ALIVE           |             保持连接             |
  |  10  |  0x20  |       READ_MEMORY_BLOCK        |        准备读取PLC内存块         |
  |  11  |  0x22  |         READ_VARIABLES         |     以bit/word方式读系统变量     |
  |  12  |  0x23  |        WRITE_VARIABLES         |     以bit/word方式写系统变量     |
  |  13  |  0x24  |      READ_COILS_REGISTERS      |       读PLC的线圈/寄存器值       |
  |  14  |  0x25  |     WRITE_COILS_REGISTERS      |       写PLC的线圈/寄存器值       |
  |  15  |  0x26  | ENABLE/DISABLE DATA DICTIONARY |      启用/关闭数据字典功能       |
  |  16  |  0x30  |       INITIALIZE_UPLOAD        |    初始化数据上传（From PLC）    |
  |  17  |  0x31  |          UPLOAD_BLOCK          |           上传PLC数据            |
  |  18  |  0x32  |      END_STRATEGY_UPLOAD       |           完成数据上传           |
  |  19  |  0x33  |      INITIALIZE_DOWNLOAD       |     初始化数据下装（To PLC）     |
  |  20  |  0x34  |         DOWNLOAD_BLOCK         |          下载数据到PLC           |
  |  21  |  0x35  |          END_DOWNLOAD          |           完成数据下载           |
  |  22  |  0x36  |  CREATE/RESTORE/REMOVE BACKUP  | 创建/恢复/删除内存卡中的数据备份 |
  |  23  |  0x39  |      READ_ETH_MASTER_DATA      |    Read Ethernet Master Data     |
  |  24  |  0x40  |           START_PLC            |             运行PLC              |
  |  25  |  0x41  |            STOP_PLC            |             停止PLC              |
  |  26  |  0x50  |          MONITOR_PLC           |           监视PLC变量            |
  |  27  |  0x58  |           CHECK_PLC            |         检查PLC连接状态          |
  |  28  |  0x70  |         READ_IO_OBJECT         |             读IO目标             |
  |  29  |  0x71  |        WRITE_IO_OBJECT         |             写IO目标             |
  |  30  |  0x73  |       GET_STATUS_MODULE        |           获取状态模块           |

- UMAS协议数据具体分析

  应/答式的通信协议：包含某种功能吗的数据发送到PLC，PLC对请求解析后按照固定格式回应数据

  请求：

  > [TCP Packet] - [Modbus Header] - [5A] - [UMAS CODE (16 bit)] - [UMAS PAYLOAD(variable)]

  响应

  > [TCP Packet] - [Modbus Header] - [5A] - [RETURN CODE (16 bit)] - [UMAS PAYLOAD(variable)]

  RETURN CODE就是状态码的部分，存在两种可能，0x01 0xFE / 0x00 0xFE意味着OK，而0x01 0xFD意味着Error

  响应数据包的基本格式为：

  > [ TCP Packet ] – [ Modbus Header ] – [5A] – [ Response Code (16) ] – [ Unknown (9 bytes) ] – [ Unknown 2 (9 bytes) ] – [ Modification date (8 bytes) ] – [ Modification date Rep (8 bytes) ] – [ Project Version (16) ] – [ Unknown (16) ] – [ Project Name length (8) – [ Project name (variable) ]

#### S7comm

- 基础知识

  S7comm = Siemens S7 = 西门子S7 (协议)

  西门子公司生产的PLC与SCADA系统进行通信的私有协议，和Modbus协议处于应用层协议不同，S7comm的协议栈修改程度更高，在应用层组织经过COTP协议和TPKT协议的进一步处理后，最终通过TCP进行传输

  |     OSI layer      |        Protocol        |
  | :----------------: | :--------------------: |
  | Application Layer  |    S7 communication    |
  | Presentation Layer | S7 communication(COTP) |
  |   Session Layer    | S7 communication(TPKT) |
  |  Transport Layer   | ISO-on-TCP (RFC 1006)  |
  |   Network Layer    |           IP           |
  |  Data Link Layer   |        Ethernet        |
  |   Physical Layer   |        Ethernet        |

- TPKT协议(会话层)

  TPKT是应用传输服务协议，主要是为上层的COTP协议和下层的TCP协议进行过滤，我们常用的RDP协议也是基于TPKT，TPKT默认端口为102，而RDP为3389

  ![img](https://i.loli.net/2019/09/06/8JeRab3nNxZBkDg.png)

  四个部分，其中version为1 byte，表明版本信息，reserved，保留字段为1 byte，length为两个字节，包括当前四个字节在内的后续TCP payload的字节长度

- COPT协议

  - COPT协议是表示层协议，连接下层TPKT和上层应用层，全称为Connection Oriented Transport Protocol，面向连接的传输协议，由此可见，COPT主要依赖于连接，所以必须有TCP握手类似的操作，因此COPT协议有两种包，首先是COPT连接包(握手包)和COPT功能包

  - COPT连接包

    - length，1byte，数据的长度，但并不包含length这个字段（个人感觉很奇怪……）

    - PDU type，1 byte，标识类型，图中的0x0d即为连接确认的类型，常有的还有

      - 0xe，连接请求
      - 0x0d，连接确认
      - 0x08，断开请求
      - 0x0c，断开确认
      - 0x05，拒绝

      ![image-20210727110210067](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210727110210067.png)

    - DST reference，2byte，目标的引用，可以认为是用来唯一标识目标

    - SRC reference，2byte，源的引用，同上

    - option，1byte，可以看到wireshark将8位拆为了前四位和后两位：

      - 前四位标识class，也就是标识类别
      - 倒数第二位对应Extended formats，是否使用拓展样式
      - 倒数第一位对应No explicit flow control，是否有明确的指定流控制

    - parameter，附加的参数字段，参数可以有多个，每个参数又由以下几个字段构成：

      - code，1byte，标识类型，主要有：

        - 0xc0，tpdu的size，tpdu即传送协议数据单元，也就是传输的数据的大小（是否和前面的length有重复之处？）

        - 0xc1，src-tsap，翻译过来应该叫源的端到端传输（在完整的TCP/IP协议栈中，这个字段代表的是应用与应用之间的通信，我这里猜测可能是为了），但从西门子给的手册来看，它标记的应该是机架号，可是不管我怎么查，也没有找到wireshark解析出的字符串。那么逆向我们找不到答案，就只能正向来了，在parameter字段的最后我们再来详细说这到底是个啥。

          [![img](https://i.loli.net/2019/09/04/IiUVYODBqEW9y6F.png)](https://i.loli.net/2019/09/04/IiUVYODBqEW9y6F.png)

        - 0xc2，dst-tsap，同上，之后我们再探索

      - length，长度

      - 对应的数据

  - COPT功能包

    - length，1byte，长度
    - PDU type，1 byte，图中为0x0f，即为数据传输，此外的type都不太常用，这里不再提了（其实是我没找到相关的流量包……有这方面流量的大佬希望补全以下）
    - option，1byte，以位为单位划分：
      - 第一位，标识是否为最后一个数据包（从这可以看出，COPT协议当数据较多时，会分为几个单元传输
      - 后七位，标识TPDU的number

- S7Comm协议层

  - S7Comm协议包括三个部分

    - Header
      - ROSCTR
        - 常见值
          - 0x01 JOB即作业请求，如读/写存储器，读/写块，启动/停止设备，设置通信
          - 0x02 ACK即确认相应，这是一个没有数据的简单确认
          - 0x03 ACK_DATA即确认数据响应，一般是响应JOB的请求
          - 0x07 USERDATA即拓展协议，其参数分段包含请求/响应ID，一般用于编程和调试，读取SZL等
    - Parameter
    - Data

  - 举例

    - 功能码为 0x05 的 S7Comm 数据包

    ![s7comm_package_func_code_05](https://crifan.github.io/industrial_control_security_overview/website/assets/img/s7comm_package_func_code_05.jpg)

    - 含义解析
      - Header：
        - 第一个字节是协议标识符 0x32
        - ROSCTR：1
          - ROSCTR 这个字段的取值决定后面 PDU 的结构，这里我们只分析取值为 0x01-JOB ，作业请求
            - 由主设备发送的请求（例如，读 / 写存储器，读 / 写块，启动 / 停止设备，设置通信）。
      - Parameter
        - S7Comm 当 ROSCTR 取值为 0x01 时，协议栈中的 Parameter 项的第一个字段是 function （功能码），大小为 1 字节
        - 功能码为 0x05 的 S7Comm 数据包查询功能码表可以确定这个数据包是写入值
          - 整理常见的 JOB 和 Ack_data 的功能码表
            - ![s7comm_job_ack_data](https://crifan.github.io/industrial_control_security_overview/website/assets/img/s7comm_job_ack_data.png)
      - data
        - 因此 Write Var 中Parameter 的结构后面要添加写入值的内容，多了一个 data 项
        - data 的结构
          - 0 (Unsigned integer, 1 byte): Return code ，返回代码
          - 1 (unsigned integer, 1 byte): Transport size ，确定变量的类型和长度
          - 2-3 (unsigned integer, 2 bytes): Length ，写入值的数据长度
          - 4 (1 byte): Data ，写入的值
          - 5 (unsigned integer, 1 byte): Fill byte ，填充字节，如果数据的长度不足 Length 的话，则填充



#### SV（暂时放一放）

SV报文分析

[SV报文分析.doc (book118.com)](https://max.book118.com/html/2017/0903/131679310.shtm)

建档文档（同Goose一起）

http://www.360doc.com/content/16/1014/20/36538220_598459873.shtml

样例

已经下载解压

#### MMS （TCP IP）

参考文档 [MMS Introduction (nettedautomation.com)](https://www.nettedautomation.com/standardization/ISO/TC184/SC5/WG2/mms_intro/)

##### 0x00 环境搭建

##### 0x01 协议介绍

首先MMS协议为Manufacturing Message Specification制造报文规范，它主要也是依赖于TCP同样也使用到了COTP这个面向连接的传输协议，COTP的作用就是进行传输连接的建立，COTP分别标记为了CR和CC，为connect request和connect confirm，就是连接和返回包，这里暂时不分析COTP

![image-20210804112053540](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210804112053540.png)

网上关于MMS的详细数据包分析相对比较少，因此结合数据包具体分析，MMS一共有14个功能码

```
confirmed-RequestPDU		[0] 	IMPLICIT Confirmed-RequestPDU,
confirmed-ResponsePDU		[1] 	IMPLICIT Confirmed-ResponsePDU,
confirmed-ErrorPDU		    [2] 	IMPLICIT Confirmed-ErrorPDU,
unconfirmed-PDU			    [3] 	IMPLICIT Unconfirmed-PDU,
rejectPDU			        [4] 	IMPLICIT RejectPDU,
cancel-RequestPDU		    [5] 	IMPLICIT Cancel-RequestPDU,
cancel-ResponsePDU		    [6] 	IMPLICIT Cancel-ResponsePDU,
cancel-ErrorPDU		     	[7] 	IMPLICIT Cancel-ErrorPDU,
initiate-RequestPDU	     	[8] 	IMPLICIT Initiate-RequestPDU,
initiate-ResponsePDU		[9] 	IMPLICIT Initiate-ResponsePDU,
initiate-ErrorPDU	    	[10] 	IMPLICIT Initiate-ErrorPDU,
conclude-RequestPDU	     	[11] 	IMPLICIT Conclude-RequestPDU,
conclude-ResponsePDU   		[12] 	IMPLICIT Conclude-ResponsePDU,
conclude-ErrorPDU		    [13] 	IMPLICIT Conclude-ErrorPDU
```

​                               



#### COAP  （TCP IP）

官方文档

[CoAP — Constrained Application Protocol | Overview](https://coap.technology/)

##### 0x00 环境搭建

chrome step by step 别跳步

https://github.com/mkovatsc/Copper4Cr

![image-20210802170119292](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210802170119292.png)

国内服务测试器为coap://wsncoap.org/，连接成功

![image-20210802170154448](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210802170154448.png)

下载安装包https://sourceforge.net/projects/libcoap/

cd 进入 ./configure & make

cd examples

./coap-server

输入coap://ip即可进行通信，随便ping几下，wireshark抓包可以得到数据

![image-20210802173137237](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210802173137237.png)

##### 0x01 介绍

Coap是一种在物联网设备上的类web协议，详细规范定义在RFC 7252，Coap就是"受限应用协议"，就是使用在资源设备受限的五脸上设备上，因为物联网设备的ram和rom相对较小，运行TCP和HTTP是不可以接受的

COAP的几个优点

- COAP协议网络传输层由TCP改为UDP
- 它基于REST，server的资源地址和互联网一样也有类似url的格式，客户端同样有POST，GET,PUT,DELETE方法来访问server，对HTTP做了简化
- COAP是二进制格式的，HTTP是文本格式的，COAP比HTTP更加紧凑
- 轻量化，COAP最小长度仅仅4B，一个HTTP的头都几十个B了
- 支持可靠传输，数据重传，块传输。 确保数据可靠到达
- 支持IP多播, 即可以同时向多个设备发送请求
- 非长连接通信，适用于低功耗物联网场景

之前没有接触过REST，详细学习REST原则，满足该原则的称之为RESTful架构，也就是Representational State Transfer

- 资源 Resources

  REST的名称为"表现层状态转化"，其实就是资源的表示层，而资源就是网络上的一个主体，可以是一个文本，一张图片，一首歌曲等

- 表现层 Representation

  把资源具体呈现出来的形式称之为表现层，比如文本用txt，也可以用html，xml，json，二进制等，图片可以用jpg，png，gif等，具体的表现形式不应该受URL的影响，而是应该在HTTP的请求头信息中的Accept和Content-Type中指定

- 状态转化 State Tranfer

  一个互动过程，囊括了数据和状态的转化，大概就是信息都在服务器，而客户端想要获取数据，必须要让服务端放生状态转化，而HTTP协议中一般用到的就是get post put delete

- 综述 RESTFUL架构

  1. URL代表资源
  2. 客户端和服务器之间，传递这种资源的表现层
  3. 客户端通过HTTP的四个动作，进行表现层状态转化

coap的协议包大概如下

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver| T |  TKL  |      Code     |          Message ID           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Token (if any, TKL bytes) ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...                                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Ver 版本号 2bits 1/4 byte 01

- T 消息类型 2bits 1/4 byte

  - 0 con 主动发出消息请求，需要接收方作出回复
  - 1 non 主动发出消息请求，不需要接收方做出回复
  - 2 ack 接收方作出回复
  - 3 res 发出CON后，没收到请求时，主动通知不再需要恢复

- TKL token length 4bits 1/2 byte 表示后面token所占字节数，如果为0表示token不存在

- code 状态码 1 byte 分为**发送方**和接收方

  code状态码一般为a.bb格式，一般转换为二进制为前三个字节为a，后面两个字节代表bb，例如2.31拆分成二进制格式就是

  > 010 11111	>	0x5f

  和HTTP类似，一般2.xx都是成功，其余都是存在问题的失败

  - 发送方

    | Code |  Name  | Value |
    | :--: | :----: | :---: |
    | 0.00 | EMPTY  | 0x00  |
    | 0.01 |  GET   | 0x01  |
    | 0.02 |  POST  | 0x02  |
    | 0.03 |  PUT   | 0x03  |
    | 0.04 | DELETE | 0x04  |

    一般EMPTY只有消息类型T为RES的时候才会使用

  - 接收方 暂时不考虑

- Message ID 消息编号 2 bytes 如果是con类型，则返回的message id应该保持与发送的一致

- token由前面的TKL所决定，如果TKL为0，则数据包不包含token

- Options 占用的字节数不定，如果包尾遇到payload标识符0xff则表示Options结束，类似于http协议的Options，存有Content-Format、URL-PATH之类的信息

  ```
    0   1   2   3   4   5   6   7
  +---------------+---------------+
  |  Option Delta | Option Length |   1 byte
  +---------------+---------------+
  /         Option Delta          /   0-2 bytes
  \          (extended)           \
  +-------------------------------+
  /         Option Length         /   0-2 bytes
  \          (extended)           \
  +-------------------------------+
  /         Option Value          /   0 or more bytes
  +-------------------------------+
  ```

  - Option Delta 4bits 1/2 byte

    |  No  |      Name      | Format | Length |   Default    |
    | :--: | :------------: | :----: | :----: | :----------: |
    |  1   |    If-Match    | opaque |  0-8   |    (none)    |
    |  3   |    Uri-Host    | string | 1-255  | (see note 1) |
    |  4   |      ETag      | opaque |  1-8   |    (none)    |
    |  5   | If-None-Match  | empty  |   0    |    (none)    |
    |  7   |    Uri-Port    |  uint  |  0-2   | (see note 1) |
    |  8   | Location-Path  | string | 0-255  |    (none)    |
    |  11  |    Uri-Path    | string | 0-255  |    (none)    |
    |  12  | Content-Format |  uint  |  0-2   |    (none)    |
    |  14  |    Max-Age     |  uint  |  0-4   |      60      |
    |  15  |   Uri-Query    | string | 0-255  |    (none)    |
    |  17  |     Accept     |  uint  |  0-2   |    (none)    |
    |  20  | Location-Query | string | 0-255  |    (none)    |
    |  28  |     Size2      |  uint  |  0-4   |    (none)    |
    |  35  |   Proxy-Uri    | string | 1-1034 |    (none)    |
    |  39  |  Proxy-Scheme  | string | 1-255  |    (none)    |
    |  60  |     Size1      |  uint  |  0-4   |    (none)    |

    Content-Formats参数的具体数值：

    |        Media type        | Id.  |
    | :----------------------: | :--: |
    | text/plain;charset=utf-8 |  0   |
    | application/link-format  |  40  |
    |     application/xml      |  41  |
    | application/octet-stream |  42  |
    |     application/exi      |  47  |
    |     application/json     |  50  |
    |     application/cbor     |  60  |

    由于Option Delta只有4位，最大只能表达15，为了解决这个问题，coap协议有着如下规定：

    - 当Option Delta号码<=12时：Option Delta位为实际的Option Delta值
    - 当Option Delta号码<269时：Option Delta位填入13；并且在后面的Option Delta(extended)位会占用1字节，并且填入的数为实际Option Delta值减去13
    - 当Option Delta号码<65804时：Option Delta位填入14；并且在后面的Option Delta(extended)位会占用2字节，并且填入的数为实际Option Delta值减去269

  - Option Length 4bits 1/2 byte

    同样最大表达15，为了解决和上面的Option Delta类似

  - **强调，Option Delta和Option Length不能为15，遇到0x0f，该包无效**

  - 多个Options的时候按照option代码值No的顺序从小到大进行排序，不然Option Delta会出错

- Payload占用字节数不定，分隔符0xff后面的数据就是payload

#### MQTT （TCP IP）

##### 0x00 介绍

很重要的信息 https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/03-ControlPackets.html

官方文档 http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html

维基百科 https://zh.wikipedia.org/wiki/MQTT

mqtt.fx安装 http://www.jensd.de/apps/mqttfx/1.7.1/

首先在ubuntu虚拟机上启动mosquitto，同时记录ip，如果出现端口占用，一般就ps -ef | grep mosquitto然后kill，往往因为进程没关闭完全

![image-20210729173828714](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729173828714.png)

打开MQTT设置IP地址为虚拟机IP，wireshark监听，publish pub主题，输入内容为123456788，然后在ubuntu进行订阅，订阅主题pub即执行mosquitto_sub -v -t pub，然后publish，得到123456789

![image-20210729174159118](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729174159118.png)

然后在mqtt中订阅主题sub

![image-20210729175041538](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729175041538.png)

点击subscribe，然后在ubuntu上输入mosuitto_pub -t sub -m 987654321，就可以在MQTT中看到987654321消息

![image-20210729175347521](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729175347521.png)

结束抓包

MQTT(Message Queuing Telemetry Transport)消息队列遥测传输协议，是一种基于发布订阅模式的轻量级通讯协议(基于TCP/IP协议)，主要优点是极少的代码和有限的带宽，为远程设备提供实时可靠的消息服务，低开销，低带宽占用，物联网和小型设备以及移动设备应用比较广泛

MQTT中比较重要的点

- 消息质量

  - QoS 0：最多分发一次。消息的传递完全依赖底层的TCP/IP网络，协议里没有定义应答和重试，消息要么只会到达服务端一次，要么根本没有到达
  - QoS 1：至少分发一次。服务器的消息接收由PUBACK消息进行确认，如果通信链路或发送设备异常，或者指定时间内没有收到确认消息，发送端会重发这条在消息头中设置了DUP位的消息
  - QoS 2：只分发一次。这是最高级别的消息传递，消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销 

  理解QoS的例子，青桔单车平时锁和服务器交互为QoS0，反正过一段发一次，发不到也没事，使用的时候QoS1，一直持续发，确保有一次确认到，付款的时候QoS2，只付款一次，别多付款

- 连接心跳保护机制

  MQTT客户端可以设置一个心跳间隔时间，一个周期没有业务数据消息，客户端发送PINGREQ消息，服务器返回PINGRESP确认，如果客户端1.5个周期没反应，断开连接

##### 0x01 协议分析

![image-20210729194614268](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729194614268.png)

首先是最开始的headflag，它为MQTT的的第一个字节，也就是下面的3代表publish

![image-20210730105707575](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210730105707575.png)

|  **名字**   | **值** | **报文流动方向** |                    **描述**                    |
| :---------: | :----: | :--------------: | :--------------------------------------------: |
|  Reserved   |   0    |       禁止       |                      保留                      |
|   CONNECT   |   1    |  客户端到服务端  |              客户端请求连接服务端              |
|   CONNACK   |   2    |  服务端到客户端  |                  连接报文确认                  |
|   PUBLISH   |   3    |  两个方向都允许  |                    发布消息                    |
|   PUBACK    |   4    |  两个方向都允许  |       QoS 1消息发布收到确认 没有payload        |
|   PUBREC    |   5    |  两个方向都允许  |     发布收到（保证交付第一步）没有payload      |
|   PUBREL    |   6    |  两个方向都允许  |     发布释放（保证交付第二步）没有payload      |
|   PUBCOMP   |   7    |  两个方向都允许  | QoS 2消息发布完成（保证交互第三步）没有payload |
|  SUBSCRIBE  |   8    |  客户端到服务端  |                 客户端订阅请求                 |
|   SUBACK    |   9    |  服务端到客户端  |                订阅请求报文确认                |
| UNSUBSCRIBE |   10   |  客户端到服务端  |               客户端取消订阅请求               |
|  UNSUBACK   |   11   |  服务端到客户端  |                取消订阅报文确认                |
|   PINGREQ   |   12   |  客户端到服务端  |                    心跳请求                    |
|  PINGRESP   |   13   |  服务端到客户端  |                    心跳响应                    |
| DISCONNECT  |   14   |  客户端到服务端  |                 客户端断开连接                 |
|  Reserved   |   15   |       禁止       |                      保留                      |

第一个字节还剩下四位，一般都是作为保留位

![image-20210730110307374](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210730110307374.png)

| **控制报文** |  **固定报头标志**  | **Bit 3** | **Bit 2** | **Bit 1** | **Bit 0** |
| :----------: | :----------------: | :-------: | :-------: | :-------: | :-------: |
|   CONNECT    |      Reserved      |     0     |     0     |     0     |     0     |
|   CONNACK    |      Reserved      |     0     |     0     |     0     |     0     |
|   PUBLISH    | Used in MQTT 3.1.1 |   DUP1    |   QoS2    |   QoS2    |  RETAIN3  |
|    PUBACK    |      Reserved      |     0     |     0     |     0     |     0     |
|    PUBREC    |      Reserved      |     0     |     0     |     0     |     0     |
|    PUBREL    |      Reserved      |     0     |     0     |     1     |     0     |
|   PUBCOMP    |      Reserved      |     0     |     0     |     0     |     0     |
|  SUBSCRIBE   |      Reserved      |     0     |     0     |     1     |     0     |
|    SUBACK    |      Reserved      |     0     |     0     |     0     |     0     |
| UNSUBSCRIBE  |      Reserved      |     0     |     0     |     1     |     0     |
|   UNSUBACK   |      Reserved      |     0     |     0     |     0     |     0     |
|   PINGREQ    |      Reserved      |     0     |     0     |     0     |     0     |
|   PINGRESP   |      Reserved      |     0     |     0     |     0     |     0     |
|  DISCONNECT  |      Reserved      |     0     |     0     |     0     |     0     |

dup为控制报文的重复分发等级

qos为服务质量等级

retain为publish报文的保留机制

![image-20210730110542204](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210730110542204.png)

- 重发标志 DUP

  如果DUP标志为0，则表示这是第一次请求发送这个publish报文，如果为1，则表示可能为一个早前报文请求的重发

  对于QoS 0的消息，必须DUP设置为0

- 服务质量等级 QoS 不能将QoS全部设为1，如果都为1，则关闭网络连接

  | **QoS值** | **Bit 2** | **Bit 1** |   **描述**   |
  | :-------: | :-------: | :-------: | :----------: |
  |     0     |     0     |     0     | 最多分发一次 |
  |     1     |     0     |     1     | 至少分发一次 |
  |     2     |     1     |     0     |  只分发一次  |
  |     -     |     1     |     1     |    保留位    |

- 保留标志 RETAIN

  如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端**必须**存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者

  一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它**必须**被发送给这个订阅者

  如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它**必须**丢弃之前为那个主题保留的任何消息。它**应该**将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都**可以**选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 

  服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它**必须**将报文的保留标志设为1

  当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端**必须**将保留标志设为0，不管它收到的这个消息中保留标志的值是多少

  保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息（现存的客户端收到的消息中保留标志未被设置。服务端**不能**存储零字节的保留消息）

  如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端**不能**存储这个消息也**不能**移除或替换任何现存的保留消息 

第二个字节开始为剩余长度

![image-20210730111212650](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210730111212650.png)

| **字节数** |             **最小值**             |              **最大值**              |
| :--------: | :--------------------------------: | :----------------------------------: |
|     1      |              0 (0x00)              |              127 (0x7F)              |
|     2      |          128 (0x80, 0x01)          |         16 383 (0xFF, 0x7F)          |
|     3      |     16 384 (0x80, 0x80, 0x01)      |     2 097 151 (0xFF, 0xFF, 0x7F)     |
|     4      | 2 097 152 (0x80, 0x80, 0x80, 0x01) | 268 435 455 (0xFF, 0xFF, 0xFF, 0x7F) |

#### GOOSE

##### 0x00 介绍

GOOSE全称为Generic Object Oriented Substation Event，是目的实现多个电子元件设备IED之间信息传递的面向通用对象的变电站事件

GOOSE因为作用为反应事件的稳态与变化，稳态情况下，以稳定的T0时间间隔一般为5S，发送GOOSE报文，当发生变化的时候，发送变化报文，T0间隔变短，变化时间发生一次后，以最短时间间隔T1，快速重传两次变化报文，在重传完成后，以T2，T3时间间隔各传输一次变位报文，最后进入稳态T0

后面的Time allowed to live一般是T0的两倍，主要用于goose延时断链的判断

##### 0x01 协议分析

查看goose包，测试样例中的appid都为0

![image-20210729154737840](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729154737840.png)

![image-20210729160944771](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729160944771.png)

|       字段        |                             描述                             |
| :---------------: | :----------------------------------------------------------: |
|       APPID       |                 ID标识，范围为0x0000~0x3fff                  |
|      Length       |                从APPID到PDU结束的全部字节长度                |
|    Reserved 1     |                      保留 默认为0x0000                       |
|    Reserved 2     |                      保留 默认为0x0000                       |
|     goosePdu      |    协议数据单元，也就是goose控制的块的信息和相关data信息     |
|      gocbRef      |               控制块引用名 如EDP01LD0/gooseST                |
| timeAllowedtolive | 允许生存时间，上图中8192，也就是说该报文在网络上允许生存的时间，超时后收到的报文被丢弃，受交换机报文交换的延迟影响 |
|      dataSet      |         数据集引用，如EDP01LD0/LLN0$All_ST_Pos，就是         |
|       goID        |                        goose控制块id                         |
|         t         |                 事件时标，该帧报文产生的时间                 |
|       stNum       |           状态号，从0开始，每产生一次变化数据，++            |
|       sqNum       |            序号，从0开始，每发送一次goose报文，++            |
|  simulation/test  | 检修状态，当检修压板投入的时候，test应该置位，goose接受装置应当接受goose报文的test位与自身的检修压板状态比较，二者一致才开始动作 |
|      confRev      | 配置版本，来自于文本控制块的confrev，可以在gooseid文本中进行配置，默认为1 |
|      ndscom       |                 needs commissioning 一般为1                  |
| numDatSetEntries  |                         数据集条目数                         |
|       data        |          数据集，一般数据集中不同类型标识不同的信息          |

|  数据类型  |         信息          |
| :--------: | :-------------------: |
|    bool    |   传输单点遥信信息    |
|    位串    |  传输双电遥信或品质q  |
| 有符号整型 |    传输直流源码值     |
| 无符号整型 |       传输档位        |
|    浮点    |    传输直流计算值     |
|    时标    | 输出UTC格式的时标信息 |

```c
IECGoosePdu::=SEQUENCE{
gocbRef                   [0]   IMPLICIT  VISIBLE-STRING,
timeAllowedtoLive         [1]   IMPLICIT  INTEGER ,
datSet                    [2]   IMPLICIT  VISIBLE-STRING,
goID                      [3]   IMPLICIT  VISIBLE-STRING OPTIONAL
t                         [4]   IMPLICIT  UtcTime,
stNum                     [5]   IMPLICIT  INTEGER,
sqNum                     [6]   IMPLICIT  INTEGER,
test                      [7]   IMPLICIT  BOOLEAN DEFAULT FALSE,
confRev                   [8]   IMPLICIT   INTEGER,
nsCom                     [9]   IMPLICIT BOOLEAN DEFAULT FALSE,
numDatSetEntries          [10]  IMPLICIT   INTEGER,
al1Data                   [11]  IMPLICIT SEQUENCE OF NamedVariableList1 
security                  [12]  ANY OPTIONAL
}
```

- 88 b8 以太网类型和APPID相关

  ![image-20210729161435446](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729161435446.png)

  ![image-20210729161445957](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729161445957.png)

- APPID 00 00

  ![image-20210729161503665](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729161503665.png)

- Length 01 7a 0x017a = 378

- 两个保留字段

- 61 82 01 6e goose pdu length，代表着goosepdu的开始，主要采用了asn.1编码

  61 = b 01100001

  asn.1编码一般为tag+length+value

  简称TLV

  ![image-20210729163119955](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729163119955.png)

  ![image-20210729163127246](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729163127246.png)

  文中为一个字节的constructed的应用，tag为1，这里定义constructed为复合结构

  然后是length，主要是标记value的字节数的，一般value长度<=127，length占一个字节，最高位为0，>127的时，第一个字节最高位为1，第一个字节剩下七位表示length的字节长度，然后第二个字节到最后一个字节表示value的长度

  ![image-20210729163444871](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729163444871.png)

  value是为信息16e，应该为长度

- gocbref 都为TLV格式

  ![image-20210729163844667](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729163844667.png)

- timeAllowedtoLive tlv 对应 81 02 10 00

- dataset （其实规律就是它的表示tag是往上+1的，后面不具体分析，都是对应TLV类型）

- goID

- t

- stnum

- sqnum

- test

- confrev

- ndscom

- numDatSetEntries

- AB 82

  从0x70这一行的AB开始到结束为data内容

  ![image-20210729165016926](%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE.assets/image-20210729165016926.png)

  tag = 0xab，上下文关联，复合结构

  前面的8开头都没有复合结构，而这里对应的为复合结构，也就是说value也是tlv组成的

  length = 0x82

##### 0x02 使用

下载地址：http://download.csdn.net/detail/xgbing/5263223

运行需要安装mms_ethereal_install_v102，下载地址：http://download.csdn.net/detail/xgbing/4233439

#### CIP

##### 0x00 官方文档

1. [odva](https://www.odva.org/technology-standards/key-technologies/common-industrial-protocol-cip/)

##### 0x01 协议学习

CIP协议(Common Industry Protocol)是端对端的面向对象协议,基于TCP/IP技术传输,分为隐式报文和显式报文,其中CIP嵌入UDP发送隐式报文,嵌入TCP发送显式报文,两者的具体适用情形如下:

| 消息类型 |    通讯关系    | 传输协议 |    通讯类型    |       适用情形       |     举例      |
| :------: | :------------: | :------: | :------------: | :------------------: | :-----------: |
|   显式   | 已连接或未连接 |   TCP    | 请求/响应 交互 | 低时间相关性数据信息 | 读写 配置字段 |
|   隐式   |     已连接     |   UDP    |  I/O 数据交换  |     实时I/O数据      | 实时控制数据  |

- CIP对象模型

  每个CIP节点都是一组对象的集合，对象由类、实例、属性构成，一个类可以有多个实例，一个实例可以有多个属性，每个类、实例、对象都有其对应的ID

  类ID分为两个部分，公共对象（范围：0x0000–0x0063, 0x00F0–0x02FF），厂家自定义对象（范围：0x0064–0x00C7, 0X0300-0X04FF）。其它范围为预留部分
  实例ID也分为两个部分，公共实例（范围：0x0001–0x0063,0x00C8-0x02FF），厂家自定义实例（范围：0x0064-0xxC7,0x0300-0x04FF）。其它范围为预留部分
  属性ID,公共属性（范围：0x0000–0x0063，0x0100–0x02FF，0x0500–0x08FF），厂家自定义属性（范围：0x0064–0x00C7，0x0300–0x04FF，0x000–0x0CFF）
 